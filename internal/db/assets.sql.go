// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assets.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAsset = `-- name: CreateAsset :one
INSERT INTO assets (name, description, group_id, owner_id) VALUES ($1, $2, $3, $4) RETURNING id, name, description, status, created_at, updated_at, group_id, owner_id
`

type CreateAssetParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	GroupID     pgtype.UUID `json:"group_id"`
	OwnerID     string      `json:"owner_id"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, createAsset,
		arg.Name,
		arg.Description,
		arg.GroupID,
		arg.OwnerID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.GroupID,
		&i.OwnerID,
	)
	return i, err
}

const createVideo = `-- name: CreateVideo :one
INSERT INTO videos (asset_id, mux_upload_id, status) VALUES ($1, $2, $3) RETURNING id, asset_id, mux_upload_id, mux_asset_id, playback_id, status, created_at, updated_at
`

type CreateVideoParams struct {
	AssetID     pgtype.UUID `json:"asset_id"`
	MuxUploadID string      `json:"mux_upload_id"`
	Status      VideoStatus `json:"status"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRow(ctx, createVideo, arg.AssetID, arg.MuxUploadID, arg.Status)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.AssetID,
		&i.MuxUploadID,
		&i.MuxAssetID,
		&i.PlaybackID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAsset = `-- name: GetAsset :one
SELECT a.id, a.name, a.description, a.status, a.created_at, a.updated_at, a.owner_id, COALESCE(v.playback_id, '') as playback_id, COALESCE(v.mux_upload_id, '') as mux_upload_id, COALESCE(v.mux_asset_id, '') as mux_asset_id FROM assets a LEFT JOIN LATERAL (SELECT playback_id, mux_upload_id, mux_asset_id FROM videos WHERE asset_id = a.id ORDER BY created_at ASC LIMIT 1) v ON true WHERE a.id = $1
`

type GetAssetRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Status      AssetStatus        `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	OwnerID     string             `json:"owner_id"`
	PlaybackID  string             `json:"playback_id"`
	MuxUploadID string             `json:"mux_upload_id"`
	MuxAssetID  string             `json:"mux_asset_id"`
}

func (q *Queries) GetAsset(ctx context.Context, id pgtype.UUID) (GetAssetRow, error) {
	row := q.db.QueryRow(ctx, getAsset, id)
	var i GetAssetRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.PlaybackID,
		&i.MuxUploadID,
		&i.MuxAssetID,
	)
	return i, err
}

const getAssetVideos = `-- name: GetAssetVideos :many
SELECT id, mux_upload_id, mux_asset_id, playback_id, status, created_at FROM videos WHERE asset_id = $1 ORDER BY created_at ASC
`

type GetAssetVideosRow struct {
	ID          pgtype.UUID        `json:"id"`
	MuxUploadID string             `json:"mux_upload_id"`
	MuxAssetID  pgtype.Text        `json:"mux_asset_id"`
	PlaybackID  pgtype.Text        `json:"playback_id"`
	Status      VideoStatus        `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetAssetVideos(ctx context.Context, assetID pgtype.UUID) ([]GetAssetVideosRow, error) {
	rows, err := q.db.Query(ctx, getAssetVideos, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetVideosRow
	for rows.Next() {
		var i GetAssetVideosRow
		if err := rows.Scan(
			&i.ID,
			&i.MuxUploadID,
			&i.MuxAssetID,
			&i.PlaybackID,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssets = `-- name: ListAssets :many
SELECT a.id, a.name, a.description, a.status, a.created_at, a.updated_at, a.owner_id, COALESCE(v.playback_id, '') as playback_id, COALESCE(v.mux_upload_id, '') as mux_upload_id, COALESCE(v.mux_asset_id, '') as mux_asset_id FROM assets a LEFT JOIN LATERAL (SELECT playback_id, mux_upload_id, mux_asset_id FROM videos WHERE asset_id = a.id ORDER BY created_at ASC LIMIT 1) v ON true WHERE a.status != 'waiting_upload' ORDER BY a.created_at DESC
`

type ListAssetsRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	Description string             `json:"description"`
	Status      AssetStatus        `json:"status"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	OwnerID     string             `json:"owner_id"`
	PlaybackID  string             `json:"playback_id"`
	MuxUploadID string             `json:"mux_upload_id"`
	MuxAssetID  string             `json:"mux_asset_id"`
}

func (q *Queries) ListAssets(ctx context.Context) ([]ListAssetsRow, error) {
	rows, err := q.db.Query(ctx, listAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssetsRow
	for rows.Next() {
		var i ListAssetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.PlaybackID,
			&i.MuxUploadID,
			&i.MuxAssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssetStatus = `-- name: UpdateAssetStatus :exec
UPDATE assets SET status = $2, updated_at = NOW() WHERE id = $1
`

type UpdateAssetStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status AssetStatus `json:"status"`
}

func (q *Queries) UpdateAssetStatus(ctx context.Context, arg UpdateAssetStatusParams) error {
	_, err := q.db.Exec(ctx, updateAssetStatus, arg.ID, arg.Status)
	return err
}

const updateVideoMuxAssetID = `-- name: UpdateVideoMuxAssetID :exec
UPDATE videos SET mux_asset_id = $2, status = 'ready', updated_at = NOW() WHERE id = $1
`

type UpdateVideoMuxAssetIDParams struct {
	ID         pgtype.UUID `json:"id"`
	MuxAssetID pgtype.Text `json:"mux_asset_id"`
}

func (q *Queries) UpdateVideoMuxAssetID(ctx context.Context, arg UpdateVideoMuxAssetIDParams) error {
	_, err := q.db.Exec(ctx, updateVideoMuxAssetID, arg.ID, arg.MuxAssetID)
	return err
}

const updateVideoStatus = `-- name: UpdateVideoStatus :exec
UPDATE videos SET mux_asset_id = $2, playback_id = $3, status = 'ready', updated_at = NOW() WHERE mux_upload_id = $1
`

type UpdateVideoStatusParams struct {
	MuxUploadID string      `json:"mux_upload_id"`
	MuxAssetID  pgtype.Text `json:"mux_asset_id"`
	PlaybackID  pgtype.Text `json:"playback_id"`
}

func (q *Queries) UpdateVideoStatus(ctx context.Context, arg UpdateVideoStatusParams) error {
	_, err := q.db.Exec(ctx, updateVideoStatus, arg.MuxUploadID, arg.MuxAssetID, arg.PlaybackID)
	return err
}

const updateVideoStatusByUploadID = `-- name: UpdateVideoStatusByUploadID :exec
UPDATE videos SET mux_asset_id = $2, playback_id = $3, status = 'ready', updated_at = NOW() WHERE mux_upload_id = $1
`

type UpdateVideoStatusByUploadIDParams struct {
	MuxUploadID string      `json:"mux_upload_id"`
	MuxAssetID  pgtype.Text `json:"mux_asset_id"`
	PlaybackID  pgtype.Text `json:"playback_id"`
}

func (q *Queries) UpdateVideoStatusByUploadID(ctx context.Context, arg UpdateVideoStatusByUploadIDParams) error {
	_, err := q.db.Exec(ctx, updateVideoStatusByUploadID, arg.MuxUploadID, arg.MuxAssetID, arg.PlaybackID)
	return err
}
